---
# Simplified Development Deployment - Single Playbook
- name: Deploy Blog App to Development Server
  hosts: dev
  become: true
  vars:
    project_dir: /opt/blogapp
    network_name: blogapp_network

  tasks:
    # ===== Docker Network Setup =====
    - name: Create Docker network
      community.docker.docker_network:
        name: "{{ network_name }}"
        state: present
      register: network_result
      ignore_errors: true

    - name: Display network status
      debug:
        msg: "Docker network '{{ network_name }}' {{ 'created' if network_result.changed else 'already exists' }}"

    # ===== Directory Setup =====
    - name: Create project directory
      file:
        path: "{{ project_dir }}"
        state: directory
        mode: "0755"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"

    - name: Create required subdirectories
      file:
        path: "{{ project_dir }}/{{ item }}"
        state: directory
        mode: "0755"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      loop:
        - conf.d
        - logs
        - ssl
        - uploads
        - nginx

    - name: Set uploads directory permissions
      file:
        path: "{{ project_dir }}/uploads"
        state: directory
        mode: "0777"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"

    # ===== Copy Configuration Files =====
    - name: Copy Docker Compose file
      copy:
        src: ../../docker-compose.dev.yml
        dest: "{{ project_dir }}/docker-compose.yml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Copy Nginx main configuration
      copy:
        src: ../../docker-apps/nginx/nginx.conf
        dest: "{{ project_dir }}/nginx/nginx.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Copy Nginx server configuration
      copy:
        src: ../../docker-apps/nginx/conf.d/docker.conf
        dest: "{{ project_dir }}/conf.d/docker.conf"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"

    - name: Copy database init script (if exists)
      copy:
        src: ../../docker-apps/database/init.sql
        dest: "{{ project_dir }}/init.sql"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0644"
      ignore_errors: true

    # ===== Create Environment File =====
    - name: Create .env file from secrets
      copy:
        dest: "{{ project_dir }}/.env"
        content: |
          # Development Environment Configuration
          # Generated: {{ ansible_date_time.iso8601 }}
          
          # Database Configuration
          MYSQL_ROOT_PASSWORD={{ mysql_root_password }}
          MYSQL_DATABASE={{ mysql_database }}
          MYSQL_USER={{ mysql_user }}
          MYSQL_PASSWORD={{ mysql_password }}
          MYSQL_PORT=3306
          
          # Backend Configuration
          DATABASE_URL=mysql+aiomysql://{{ mysql_user }}:{{ mysql_password }}@blogapp_mysql:3306/{{ mysql_database }}
          SECRET_KEY={{ secret_key }}
          ALGORITHM=HS256
          ACCESS_TOKEN_EXPIRE_MINUTES=30
          CORS_ORIGINS=http://{{ DEV_SERVER_IP }},http://{{ DEV_SERVER_IP }}:8081,https://dev-blogapp.internal.rtg-homelabs.tech
          STATIC_URL=https://dev-blogapp.internal.rtg-homelabs.tech
          DEBUG=True
          API_PREFIX=/api
          PORT=8000
          BACKEND_PORT={{ backend_port }}
          
          # PhpMyAdmin
          PHPMYADMIN_PORT={{ phpmyadmin_port }}
          
          # Docker Configuration
          GITHUB_REPOSITORY_OWNER={{ github_repository_owner }}
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0600"

    # ===== Docker Operations =====
    - name: Log in to GitHub Container Registry
      community.docker.docker_login:
        registry: ghcr.io
        username: "{{ github_actor }}"
        password: "{{ github_token }}"

    - name: Pull latest images
      command: docker compose pull
      args:
        chdir: "{{ project_dir }}"
      register: pull_result

    - name: Display pulled images
      debug:
        var: pull_result.stdout_lines
      when: pull_result.stdout_lines is defined

    - name: Stop existing containers
      command: docker compose down --timeout 30
      args:
        chdir: "{{ project_dir }}"
      ignore_errors: true

    - name: Start containers
      command: docker compose up -d --remove-orphans
      args:
        chdir: "{{ project_dir }}"
      register: start_result

    - name: Display startup result
      debug:
        var: start_result.stdout_lines
      when: start_result.stdout_lines is defined

    # ===== Health Checks =====
    - name: Wait for MySQL container to be ready
      command: docker exec blogapp_mysql mysqladmin ping -h localhost
      register: mysql_ready
      retries: 18
      delay: 10
      until: mysql_ready.rc == 0
      changed_when: false

    # ===== Ensure MySQL User Exists =====
    - name: Check if MySQL user exists
      command: >
        docker exec blogapp_mysql mysql -u root -p{{ mysql_root_password }}
        -e "SELECT User FROM mysql.user WHERE User='{{ mysql_user }}';"
      register: user_check
      changed_when: false
      failed_when: false

    - name: Create MySQL user if not exists
      command: >
        docker exec blogapp_mysql mysql -u root -p{{ mysql_root_password }}
        -e "CREATE USER IF NOT EXISTS '{{ mysql_user }}'@'%' IDENTIFIED WITH mysql_native_password BY '{{ mysql_password }}';
        GRANT ALL PRIVILEGES ON {{ mysql_database }}.* TO '{{ mysql_user }}'@'%';
        FLUSH PRIVILEGES;"
      when: user_check.stdout.find(mysql_user) == -1
      register: user_created

    - name: Display user creation result
      debug:
        msg: "{{ 'MySQL user created successfully' if user_created.changed else 'MySQL user already exists' }}"

    - name: Verify user can connect
      command: >
        docker exec blogapp_mysql mysqladmin ping 
        -h localhost -u {{ mysql_user }} -p{{ mysql_password }}
      register: db_health
      retries: 3
      delay: 5
      until: db_health.rc == 0
      changed_when: false

    - name: Restart backend after user creation
      command: docker restart blogapp-backend
      when: user_created.changed
      ignore_errors: true

    - name: Wait for backend to be healthy
      uri:
        url: "http://localhost:{{ backend_port }}/health"
        method: GET
        timeout: 10
      register: backend_health
      retries: 12
      delay: 10
      until: backend_health.status == 200
      changed_when: false
      ignore_errors: true

    - name: Get container status
      command: docker ps --format "table {% raw %}{{.Names}}\t{{.Status}}\t{{.Ports}}{% endraw %}"
      register: container_status
      changed_when: false

    - name: Display container status
      debug:
        msg: "{{ container_status.stdout_lines }}"

    # ===== Cleanup =====
    - name: Prune unused images
      command: docker image prune -f
      ignore_errors: true

    # ===== Summary =====
    - name: Display deployment summary
      debug:
        msg:
          - "ðŸŽ‰ Development Deployment Completed!"
          - "Version: {{ app_version | default('latest') }}"
          - "Frontend: http://{{ DEV_SERVER_IP }}"
          - "Backend: http://{{ DEV_SERVER_IP }}:{{ backend_port }}"
          - "API Docs: http://{{ DEV_SERVER_IP }}:{{ backend_port }}/api/docs"
          - "phpMyAdmin: http://{{ DEV_SERVER_IP }}:{{ phpmyadmin_port }}"
          - ""
          - "ðŸ“‹ Check container logs: docker logs <container_name>"
